# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @export
display <- function(im) {
    invisible(.Call('imager_display', PACKAGE = 'imager', im))
}

#' Apply recursive Deriche filter.
#' @param sigma Standard deviation of the filter.
#' @param order Order of the filter. Can be <tt>{ 0=smooth-filter | 1=1st-derivative | 2=2nd-derivative }</tt>.
#' @param axis Axis along which the filter is computed. Can be <tt>{ 'x' | 'y' | 'z' | 'c' }</tt>.
#' @param boundary_conditions Boundary conditions. Can be <tt>{ 0=dirichlet | 1=neumann }</tt>.
#' @export
deriche <- function(inp, sigma, order = 0L, axis = 'x', boundary_conditions = 0L) {
    .Call('imager_deriche', PACKAGE = 'imager', inp, sigma, order, axis, boundary_conditions)
}

#' Van Vliet recursive Gaussian filter.
#'
#'       From: I.T. Young, L.J. van Vliet, M. van Ginkel, Recursive Gabor filtering.
#'       IEEE Trans. Sig. Proc., vol. 50, pp. 2799-2805, 2002.
#'       (this is an improvement over Young-Van Vliet, Sig. Proc. 44, 1995)
#'
#'       Boundary conditions (only for order 0) using Triggs matrix, from
#'       B. Triggs and M. Sdika. Boundary conditions for Young-van Vliet
#'       recursive filtering. IEEE Trans. Signal Processing,
#'       vol. 54, pp. 2365-2367, 2006.
#'
#'       @param sigma standard deviation of the Gaussian filter
#'       @param order the order of the filter 0,1,2,3
#'       @param axis  Axis along which the filter is computed. Can be <tt>{ 'x' | 'y' | 'z' | 'c' }</tt>.
#'       @param boundary_conditions Boundary conditions. Can be <tt>{ 0=dirichlet | 1=neumann }</tt>.
#'       (Dirichlet boundary condition has a strange behavior)
#' @export
vanvliet <- function(inp, sigma, order = 0L, axis = 'x', boundary_conditions = 0L) {
    .Call('imager_vanvliet', PACKAGE = 'imager', inp, sigma, order, axis, boundary_conditions)
}

#' Blur image isotropically.
#' @param sigma Standard deviation of the blur.
#' @param boundary_conditions Boundary conditions. Can be <tt>{ 0=dirichlet | 1=neumann }
#' @seealso
#'  deriche(), vanvliet().
#' @export
isoblur <- function(inp, sigma, boundary_conditions = TRUE, is_gaussian = FALSE) {
    .Call('imager_isoblur', PACKAGE = 'imager', inp, sigma, boundary_conditions, is_gaussian)
}

#' Blur image with the median filter.
#'    
#'  @param n Size of the median filter.
#'  @param threshold Threshold used to discard pixels too far from the current pixel value in the median computation.
#' @export
medianblur <- function(inp, n, threshold) {
    .Call('imager_medianblur', PACKAGE = 'imager', inp, n, threshold)
}

#' Blur image with a box filter.
#' @param sigma Size of the box window.
#' @param boundary_conditions Boundary conditions. Can be <tt>{ 0=dirichlet | 1=neumann }</tt>.a
#' @seealso deriche(), vanvliet().
#' @export
boxblur <- function(inp, sigma, boundary_conditions = TRUE) {
    .Call('imager_boxblur', PACKAGE = 'imager', inp, sigma, boundary_conditions)
}

#' Blur image with a box filter.
#'
#' This is a recursive algorithm, not depending on the values of the box kernel size.
#'
#'       @param sigma_x Size of the box window, along the X-axis.
#'       @param sigma_y Size of the box window, along the Y-axis.
#'       @param sigma_z Size of the box window, along the Z-axis.
#'       @param boundary_conditions Boundary conditions. Can be <tt>{ false=dirichlet | true=neumann }</tt>.
#'       @seealso blur().
#'
#' @export
boxblur_xy <- function(inp, sx, sy, boundary_conditions = TRUE) {
    .Call('imager_boxblur_xy', PACKAGE = 'imager', inp, sx, sy, boundary_conditions)
}

#' Correlate image by a mask.
#'
#'  The correlation of the image instance this by the mask mask is defined to be:
#'  res(x,y,z) = sum_{i,j,k} (*this)(x + i,y + j,z + k)*mask(i,j,k).
#'
#'       @param mask = the correlation kernel.
#'       @param boundary_conditions = the border condition type (0=zero, 1=dirichlet)
#'       @param is_normalized = enable local normalization.
#'      
#'
#' @export
correlate <- function(im, filter, boundary_conditions = TRUE, is_normalised = FALSE) {
    .Call('imager_correlate', PACKAGE = 'imager', im, filter, boundary_conditions, is_normalised)
}

#' Convolve image by a mask.
#'
#'      The result  res of the convolution of an image img by a mask mask is defined to be:
#'       res(x,y,z) = sum_{i,j,k} img(x-i,y-j,z-k)*mask(i,j,k)
#'
#'       @param mask = the correlation kernel.
#'       @param boundary_conditions = the border condition type (0=zero, 1=dirichlet)
#'       @param is_normalized = enable local normalization.
#'
#'
#' @export
convolve <- function(im, filter, boundary_conditions = TRUE, is_normalised = FALSE) {
    .Call('imager_convolve', PACKAGE = 'imager', im, filter, boundary_conditions, is_normalised)
}

#' Erode image by a structuring element.
#'
#' @param mask Structuring element.
#'       @param boundary_conditions Boundary conditions.
#'       @param is_normalized Tells if the erosion is locally normalized.
#'
#' @export
erode <- function(im, mask, boundary_conditions = TRUE, is_normalised = FALSE) {
    .Call('imager_erode', PACKAGE = 'imager', im, mask, boundary_conditions, is_normalised)
}

#' Erode image by a rectangular structuring element of specified size.
#'       @param sx Width of the structuring element.
#'       @param sy Height of the structuring element.
#'       @param sz Depth of the structuring element.
#'
#'
#' @export
erode_rect <- function(im, sx, sy, sz = 1L) {
    .Call('imager_erode_rect', PACKAGE = 'imager', im, sx, sy, sz)
}

#' Erode image by a  square structuring element of specified size.
#'       @param size size of the structuring element.
#'
#' @export
erode_square <- function(im, size) {
    .Call('imager_erode_square', PACKAGE = 'imager', im, size)
}

#' Dilate image by a structuring element.
#'      @param mask Structuring element.
#'       @param boundary_conditions Boundary conditions.
#'       @param is_normalized Tells if the erosion is locally normalized.
#' @export
dilate <- function(im, mask, boundary_conditions = TRUE, is_normalised = FALSE) {
    .Call('imager_dilate', PACKAGE = 'imager', im, mask, boundary_conditions, is_normalised)
}

#' Dilate image by a rectangular structuring element of specified size.
#'
#'       @param sx Width of the structuring element.
#'       @param sy Height of the structuring element.
#'       @param sz Depth of the structuring element.
#' @export
dilate_rect <- function(im, sx, sy, sz = 1L) {
    .Call('imager_dilate_rect', PACKAGE = 'imager', im, sx, sy, sz)
}

#' Dilate image by a square structuring element of specified size.
#'
#'       @param size Size of the structuring element.
#' @export
dilate_square <- function(im, size) {
    .Call('imager_dilate_square', PACKAGE = 'imager', im, size)
}

#' Compute watershed transform.
#'
#'       Non-zero values are propagated to zero-valued ones according to
#'       the priority map.
#'       @param priority Priority map.
#'       @param fill_lines Tells if watershed lines must be filled or not.
#'
#' @export
watershed <- function(im, priority, fill_lines) {
    .Call('imager_watershed', PACKAGE = 'imager', im, priority, fill_lines)
}

#' Sharpen image.
#'
#'       @param amplitude Sharpening amplitude
#'       @param sharpen_type Select sharpening method. Can be <tt>{ false=inverse diffusion | true=shock filters }</tt>.
#'       @param edge Edge threshold (shock filters only).
#'       @param alpha Gradient smoothness (shock filters only).
#'       @param sigma Tensor smoothness (shock filters only).
#'
#' @export
sharpen <- function(im, amplitude, sharpen_type = FALSE, edge = 1, alpha = 0, sigma = 0) {
    .Call('imager_sharpen', PACKAGE = 'imager', im, amplitude, sharpen_type, edge, alpha, sigma)
}

#' Compute image gradient.
#'
#' @param axes Axes considered for the gradient computation, as a C-string (e.g "xy").
#' @param scheme = Numerical scheme used for the gradient computation:
#'       1 = Backward finite differences
#'       0 = Centered finite differences
#'       1 = Forward finite differences
#'       2 = Using Sobel masks
#'       3 = Using rotation invariant masks
#'       4 = Using Deriche recursive filter.
#'       5 = Using Van Vliet recursive filter.
#' @return a list of images (corresponding to the different directions)
#' @export
get_gradient <- function(im, axes = "", scheme = 3L) {
    .Call('imager_get_gradient', PACKAGE = 'imager', im, axes, scheme)
}

#' Return image hessian.
#'       @param axes Axes considered for the hessian computation, as a character string (e.g "xy").
#' @export
get_hessian <- function(im, axes = "") {
    .Call('imager_get_hessian', PACKAGE = 'imager', im, axes)
}

#' Compute field of diffusion tensors for edge-preserving smoothing.
#'
#'       @param sharpness Sharpness
#'       @param anisotropy Anisotropy
#'       @param alpha Standard deviation of the gradient blur.
#'       @param sigma Standard deviation of the structure tensor blur.
#'       @param is_sqrt Tells if the square root of the tensor field is computed instead.
#' @export
diffusion_tensors <- function(im, sharpness = 0.7, anisotropy = 0.6, alpha = 0.6, sigma = 1.1, is_sqrt = FALSE) {
    .Call('imager_diffusion_tensors', PACKAGE = 'imager', im, sharpness, anisotropy, alpha, sigma, is_sqrt)
}

#' Compute Haar multiscale wavelet transform.
#'
#'       @param axis Axis considered for the transform.
#'       @param invert Set inverse of direct transform.
#'       @param nb_scales Number of scales used for the transform.
#'
#' @export
haar <- function(im, inverse = FALSE, nb_scales = 1L) {
    .Call('imager_haar', PACKAGE = 'imager', im, inverse, nb_scales)
}

#' @export
FFT_complex <- function(real, imag, inverse = FALSE, nb_threads = 0L) {
    .Call('imager_FFT_complex', PACKAGE = 'imager', real, imag, inverse, nb_threads)
}

#' Estimate displacement field between two images.
#'
#' @param source Reference image.
#' @param smoothness Smoothness of estimated displacement field.
#' @param precision Precision required for algorithm convergence.
#' @param nb_scales Number of scales used to estimate the displacement field.
#' @param iteration_max Maximum number of iterations allowed for one scale.
#' @param is_backward If false, match I2(X + U(X)) = I1(X), else match I2(X) = I1(X - U(X)).
#' @export
displacement <- function(sourceIm, destIm, smoothness = 0.1f, precision = 5.0f, nb_scales = 0L, iteration_max = 10000L, is_backward = FALSE) {
    .Call('imager_displacement', PACKAGE = 'imager', sourceIm, destIm, smoothness, precision, nb_scales, iteration_max, is_backward)
}

#' @export
interp_xy <- function(inp, ix, iy, z = 0L, c = 0L, cubic = FALSE) {
    .Call('imager_interp_xy', PACKAGE = 'imager', inp, ix, iy, z, c, cubic)
}

#' @export
interp_xyz <- function(inp, ix, iy, iz, c = 0L, cubic = FALSE) {
    .Call('imager_interp_xyz', PACKAGE = 'imager', inp, ix, iy, iz, c, cubic)
}

#' @export
interp_xyzc <- function(inp, ix, iy, iz, ic, cubic = FALSE) {
    .Call('imager_interp_xyzc', PACKAGE = 'imager', inp, ix, iy, iz, ic, cubic)
}

#' @export
interp_xyc <- function(inp, ix, iy, z, ic, cubic = FALSE) {
    .Call('imager_interp_xyc', PACKAGE = 'imager', inp, ix, iy, z, ic, cubic)
}

#' Autocrop image region 
#'
#' @param color Color used for the crop. If \c 0, color is guessed.
#' @param axes Axes used for the crop.
#' @export
autocrop <- function(im, color, axes = "zyx") {
    .Call('imager_autocrop', PACKAGE = 'imager', im, color, axes)
}

#' Rotate image by an arbitrary angle.
#'
#' Most of the time, the size of the image is modified.
#'
#' @param angle Rotation angle, in degrees.
#' @param interpolation Type of interpolation. Can be <tt>{ 0=nearest | 1=linear | 2=cubic }</tt>.
#' @param boundary Boundary conditions. Can be <tt>{  0=dirichlet | 1=neumann | 2=periodic }</tt>.
#' @export
rotate <- function(im, angle, interpolation = 1L, boundary = 0L) {
    .Call('imager_rotate', PACKAGE = 'imager', im, angle, interpolation, boundary)
}

#' Rotate image by an arbitrary angle, around a center point.
#'
#'       @param angle Rotation angle, in degrees.
#'       @param cx X-coordinate of the rotation center.
#'       @param cy Y-coordinate of the rotation center.
#'       @param zoom Zoom factor.
#'       @param boundary_conditions Boundary conditions. Can be <tt>{ 0=dirichlet | 1=neumann | 2=periodic }</tt>.
#'       @param interpolation_type Type of interpolation. Can be <tt>{ 0=nearest | 1=linear | 2=cubic }</tt>.
#'
#' @export
rotate_xy <- function(im, angle, cx, cy, zoom = 1, interpolation = 1L, boundary = 0L) {
    .Call('imager_rotate_xy', PACKAGE = 'imager', im, angle, cx, cy, zoom, interpolation, boundary)
}

#' Mirror image content along specified axis 
#'       @param axis Mirror axis ("x","y","z","c")
#' @export
mirror <- function(im, axis) {
    .Call('imager_mirror', PACKAGE = 'imager', im, axis)
}

#' @export
permute_axes <- function(im, perm) {
    .Call('imager_permute_axes', PACKAGE = 'imager', im, perm)
}

#' Resize image to double-size, using the Scale2X algorithm.
#'
#'Use anisotropic upscaling algorithm
#'       <a href="http://scale2x.sourceforge.net/algorithm.html">described here</a>.
#' @export
resize_doubleXY <- function(im) {
    .Call('imager_resize_doubleXY', PACKAGE = 'imager', im)
}

#' Resize image to half-size, using an optimized filter
#'
#'Use anisotropic upscaling algorithm
#'       <a href="http://scale2x.sourceforge.net/algorithm.html">described here</a>.
#' @export
resize_halfXY <- function(im) {
    .Call('imager_resize_halfXY', PACKAGE = 'imager', im)
}

#' Resize image to triple-size, using the Scale2X algorithm.
#'
#'Use anisotropic upscaling algorithm
#'       <a href="http://scale2x.sourceforge.net/algorithm.html">described here</a>.
#' @export
resize_tripleXY <- function(im) {
    .Call('imager_resize_tripleXY', PACKAGE = 'imager', im)
}

#' Shift image content.
#'
#'       @param delta_x Amount of displacement along the X-axis.
#'       @param delta_y Amount of displacement along the Y-axis.
#'       @param delta_z Amount of displacement along the Z-axis.
#'       @param delta_c Amount of displacement along the C-axis.
#'       @param boundary_conditions can be:
#'          - 0: Zero border condition (Dirichlet).
#'          - 1: Nearest neighbors (Neumann).
#'          - 2: Repeat Pattern (Fourier style).
#' @export
shift <- function(im, delta_x, delta_y = 0L, delta_z = 0L, delta_c = 0L, boundary_conditions = 0L) {
    .Call('imager_shift', PACKAGE = 'imager', im, delta_x, delta_y, delta_z, delta_c, boundary_conditions)
}

#' @export
split <- function(im, axis, nb = -1L) {
    .Call('imager_split', PACKAGE = 'imager', im, axis, nb)
}

#' Resize image to new dimensions.
#' If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
#' @param size_x Number of columns (new size along the X-axis).
#' @param size_y Number of rows (new size along the Y-axis).
#' @param size_z Number of slices (new size along the Z-axis).
#' @param size_c Number of vector-channels (new size along the C-axis).
#' @param interpolation_type Method of interpolation:
#' 1 = no interpolation: raw memory resizing.
#' 0 = no interpolation: additional space is filled according to \p boundary_conditions.
#' 1 = nearest-neighbor interpolation.
#' 2 = moving average interpolation.
#' 3 = linear interpolation.
#' 4 = grid interpolation.
#' 5 = cubic interpolation.
#' 6 = lanczos interpolation.
#' @param boundary_conditions Border condition type.
#' @param centering_x Set centering type (only if \p interpolation_type=0).
#' @param centering_y Set centering type (only if \p interpolation_type=0).
#' @param centering_z Set centering type (only if \p interpolation_type=0).
#' @param centering_c Set centering type (only if \p interpolation_type=0).
#' @export
resize <- function(im, size_x, size_y = -100L, size_z = -100L, size_c = -100L, interpolation_type = 1L, boundary_conditions = 0L, centering_x = 0, centering_y = 0, centering_z = 0, centering_c = 0) {
    .Call('imager_resize', PACKAGE = 'imager', im, size_x, size_y, size_z, size_c, interpolation_type, boundary_conditions, centering_x, centering_y, centering_z, centering_c)
}

#' @export
load_image <- function(fname) {
    .Call('imager_load_image', PACKAGE = 'imager', fname)
}

#' @export
save_image <- function(im, fname) {
    invisible(.Call('imager_save_image', PACKAGE = 'imager', im, fname))
}

#' @export
testas <- function(inp) {
    .Call('imager_testas', PACKAGE = 'imager', inp)
}

